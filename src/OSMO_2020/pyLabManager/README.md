## Introduction

labManager is an independent, open-source scalabale lab managment software, built around RS-232 communication with industry-standard equipment. Development is currently in progress for Just Biotherapudic to be used for automation.

### Unknowns / Further Research

* *Operator ID* - Lab insturments post a value labeled 'Operator ID' when communicating a result or recalling result. There is a potential this field can be used to further improve automation.
* *Two-Way Communication* - Unfortunatly, all communication between insturments is currently one way. A user initilizes the sample, then software handles the reception of the data. In multiple intrument manuals, there is mention of two-way communication, however this functionality has not been tested.
* ~~*Enumerating OSMO Communcation Cases* - Not all possible messages have been recorded and identified for the OSMO 2020. Thus, there are many holes in `OSMO2020Manager.py`, corresponding to the unknowns.~~
    * ~~Power on~~
    * ~~Save configuration~~
    * ~~Recall Results~~
    * ~~Report Results~~

## Documentation

### **`result.py`**

Description 

- This file outlines the Result object. Results bridge the hardware manager to a human-friendly medium. Results are created by request through Ignition. On creatation a sample ID is assoiced with the object, a data condition is set, desired insturment is specified. (Nb: Each individual insturment has a unique serial number. If needed, the serial can be assoiced with a human-friendly designation, for example, OSMO 1 or OSMO 2.)

- Results are designed to be customizible, with the assumtion that in practice multiple lab insturments of the same model will be active, and there is a potential for conflict within users.

Paramaters / Varibles assoicated with a `result` object
* Sample ID (In the format S-2019MM/DD[?])
* Units 
* Value (realtive to the units)
* Timestamp of request
* Coprresponding Insturment (OSMO vs. YSI)
* Insturment SN (Nb: In the future 'Coprresponding Insturment' and 'Instrument SN' could be combined)
* Have a default value in case of error [**UNWRITTEN**] 


- Recieveing data is (arguibly) the hardest thing to design in `result.py`. There are many different theoretical methods for how/when a user would want data received, and it is nessissary to design a system that prepaired for all of them.

Methods For Receiving Data
* Wait until a time [**UNWRITTEN**]
* Assume it is in input buffer, and read it directly [**UNWRITTEN**]
* Wait until the input buffer is the proper size, then read it out [**UNWRITTEN**]



### **`hardwareManager.py`**

Description

- hardwareManager is responsible for managing all of the hardware objects and their states. The hardwareManager is a singleton, and maintains a list of all Inturment Managers. The hardware manager is the first line of communication between a result generated by the user, and the physical devices.

- The manager is designed with a focus on slowly de-escalating abstractions, and providiing a high ceiling to scalable development. The hardwareManager does not have a hard limit of Inturment Managers. 

Methods / Varibles assoiaced with the Hardware Manager:
* List of all Inturment Managers
* A method to find an insturment by serial number
* A method to find all insturment of a model 
* A method to regiser a insturmentManager

### **`OSMO2020Manager.py`**

Description

- The OSMO 2020 manager is a proof-of-concept for instument managers. It is the first non-singleton object. The creation of instument managers is highly customizable, they can be created from a file configuration, created in small quantitys in main.py, or remotely-created from ignition or a webserver.

Methods / Varibles assoiaced with the OSMO2020 Manager:
* A method to parse data in the input buffer in 'recall data' format
* A method to parse data in the input buffer in 'result reporting' format
* A method to block for N bytes of data
* A method to block for self-identify (I.E Determine what message was sent based on only the message) [**UNWRITTEN**]
* A method to decode a passed message [**UNWRITTEN**]

## Implementation

### **`main.py`**

## OSMO 2020 Serial Command Structure

The theory was, if enough log files were collected and analyzed carefully enough, you could get a good idea of what the command structure was, even without a users manuel. Thus, a **majoiry** of the commands and their respective byte patterns have been found. 

### Recall Results
  * Header : 19 Bytes
    * `“1.<space>Recall Results\r\n”`
  * Table Header : 116 Bytes
    * `“  #    Result       ID                   Date/Time  \r\n  ==========================================================\r\n”`
    * Need to come back to this to double check newline characters + spaces
    * 116 Bytes is an estimate from stitching together tests
  * Results : 65 Bytes
    * `"<space*2>199:  287 mOsm/kg                      09/21/2019 09:36:14 AM\r\n"`
    * For the record, we know for a fact the results are appended every 65 bytes, we don’t know for sure how often the heading is
### Result Reporting (Doing a real test)
  * Header : 111 Bytes
      `Operator ID: ___________________
      SN: 05030326A
      09/21/2019 10:32:33 AM
      ================================\r\n”`
  * Result : 15 Bytes
    * `"6:  303 ID: \r\n”`
  * Footer : 60 Bytes 
    * `"================================\r\nTray Complete<space*11>\r\n""` 
    * Need to double check - Spaces at the end were manually counted from hex
### Statistics

TODO: Finish the remainder of the commands
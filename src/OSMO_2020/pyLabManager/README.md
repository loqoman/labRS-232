## Introduction

labManager is an independent, open-source scalabale lab managment software, built around RS-232 communication with industry-standard equipment. Development is currently in progress for Just Biotherapudic to be used for automation.

### Unknowns / Further Research

* *Operator ID* - Lab insturments post a value labeled 'Operator ID' when communicating a result or recalling result. There is a potential this field can be used to further improve automation.
* *Two-Way Communication* - Unfortunatly, all communication between insturments is currently one way. A user initilizes the sample, then software handles the reception of the data. In multiple intrument manuals, there is mention of two-way communication, however this functionality has not been tested.
* *Enumerating OSMO Communcation Cases* - Not all possible messages have been recorded and identified for the OSMO 2020. Thus, there are many holes in `OSMO2020Manager.py`, corresponding to the unknowns. Bolded scenarios have been tested.
    * Power on
    * Save configuration
    * **Recall Results**
    * **Report Results**

## Documentation

### **`result.py`**

Description 

- This file outlines the Result object. Results bridge the hardware manager to a human-friendly medium. Results are created by request through Ignition. On creatation a sample ID is assoiced with the object, a data condition is set, desired insturment is specified. (Nb: Each individual insturment has a unique serial number. If needed, the serial can be assoiced with a human-friendly designation, for example, OSMO 1 or OSMO 2.)

- Results are designed to be customizible, with the assumtion that in practice multiple lab insturments of the same model will be active, and there is a potential for conflict within users.

Paramaters / Varibles assoicated with a `result` object
* Sample ID (In the format S-2019MM/DD[?])
* Units 
* Value (realtive to the units)
* Timestamp of request
* Coprresponding Insturment (OSMO vs. YSI)
* Insturment SN (Nb: In the future 'Coprresponding Insturment' and 'Instrument SN' could be combined)
* Have a default value in case of error [**UNWRITTEN**] 


- Recieveing data is (arguibly) the hardest thing to design in `result.py`. There are many different theoretical methods for how/when a user would want data received, and it is nessissary to design a system that prepaired for all of them.

Methods For Receiving Data
* Wait until a time [**UNWRITTEN**]
* Assume it is in input buffer, and read it directly [**UNWRITTEN**]
* Wait until the input buffer is the proper size, then read it out [**UNWRITTEN**]



### **`hardwareManager.py`**

Description

- hardwareManager is responsible for managing all of the hardware objects and their states. The hardwareManager is a singleton, and maintains a list of all Inturment Managers. The hardware manager is the first line of communication between a result generated by the user, and the physical devices.

- The manager is designed with a focus on slowly de-escalating abstractions, and providiing a high ceiling to scalable development. The hardwareManager does not have a hard limit of Inturment Managers. 

Methods / Varibles assoiaced with the Hardware Manager:
* List of all Inturment Managers
* A method to find an insturment by serial number
* A method to find all insturment of a model 
* A method to regiser a insturmentManager

### **`OSMO2020Manager.py`**

Description

- The OSMO 2020 manager is a proof-of-concept for instument managers. It is the first non-singleton object. The creation of instument managers is highly customizable, they can be created from a file configuration, created in small quantitys in main.py, or remotely-created from ignition or a webserver.

Methods / Varibles assoiaced with the OSMO2020 Manager:
* A method to parse data in the input buffer in 'recall data' format
* A method to parse data in the input buffer in 'result reporting' format
* A method to block for N bytes of data
* A method to block for self-identify (I.E Determine what message was sent based on only the message) [**UNWRITTEN**]
* A method to decode a passed message [**UNWRITTEN**]


## Implementation

### **`main.py`**
